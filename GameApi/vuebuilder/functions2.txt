new: BM bitmap_api::newbitmap(int sx = 100, int sy = 100, unsigned int color = 00000000);
load: BM bitmap_api::loadbitmap(std::string filename = test.png);
save_png: ML bitmap_api::save_png_ml(EveryApi& ev = ev, BM bm = , std::string filename = test.png);
bm_url: BM bitmap_api::loadbitmapfromurl(std::string url = http://tpgames.org/gameapi_logo.png);
bm_fetch: TXID bitmap_api::dyn_fetch_bitmap(EveryApi& ev = ev, std::string url = http://tpgames.org/gameapi_logo.png, int reload_frame = 300000);
bm_gltf: BM polygon_api::gltf_load_bitmap(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/DamagedHelmet.glb, int image_index = 0);
bm_atlas_x: [BM] sprite_api::sprite_atlas_x(EveryApi& ev = ev, BM orig = , int start_x = 0, int end_x = 10, int start_y = 0, int end_y = 10, int delta_x = 10, int count = 2);
bm_atlas_y: [BM] sprite_api::sprite_atlas_y(EveryApi& ev = ev, BM orig = , int start_x = 0, int end_x = 10, int start_y = 0, int end_y = 10, int delta_y = 10, int count = 2);
bm_atlas_xy: [BM] sprite_api::sprite_atlas_xy(EveryApi& ev = ev, BM orig = , int start_x = 0, int end_x = 10, int start_y = 0, int end_y = 10, int delta_x = 10, int delta_y = 10, int count_x = 2, int count_y = 2);
bm_cubemap: [BM] bitmap_api::cubemap(BM bm = );
bm_invcubemap: BM bitmap_api::bm_cubemap(EveryApi& ev = ev, BM left = , BM top = , BM middle = , BM right = , BM back = , BM down = , int sx = 256, int sy = 256);
edge_fix: BM bitmap_api::fix_edges(BM bm = );
border: BM bitmap_api::border(BM bm = , int left = 5, int right = 5, int top = 5, int bottom = 5);
add_shape_border: BM bitmap_api::add_shape_border(EveryApi& ev = ev, BM bm = , float dist_field_size = 7.0, float start_range = 0.5, float end_range = 0.9, int r = 0, int g = 0, int b = 0, int a = 255, int border_size = 5);
bm_choose_color: BB bitmap_api::choose_color(BM bm = , unsigned int c1 = ffffffff, unsigned int c2 = 00888888);
sub: BM bitmap_api::subbitmap(BM orig = , int x = 0, int y = 0, int width = 100, int height = 100);
alt: BM bitmap_api::alt([BM] vec = , int index = 0);
compose_x: BM bitmap_api::compose_x(BM bm1 = , BM bm2 = );
compose_y: BM bitmap_api::compose_y(BM bm1 = , BM bm2 = );
blit: BM bitmap_api::blitbitmap(BM bg = , BM orig = , int x = 0, int y = 0);
blitFB: BM bitmap_api::blitbitmap_fb(BM bg = , BM orig = , int x = 0, int y = 0, FB mask = );
blitBB: BM bitmap_api::blitbitmap_bb(BM bg = , BM orig = , int x = 0, int y = 0, BB mask = );
bm_scale: BM bitmap_api::scale_bitmap(EveryApi& ev = ev, BM orig = , int sx = 800, int sy = 600);
bm_fullscreen: BM bitmap_api::scale_bitmap_fullscreen(EveryApi& ev = ev, BM orig = );
interpolate: BM bitmap_api::interpolate_bitmap(BM orig1 = , BM orig2 = , float x = 0.0);
bm_color: BM bitmap_api::color_bm(BM bm = , unsigned int color = fff8844);
bm_plus: BM bitmap_api::plus_bitmap(BM bm1 = , BM bm2 = );
bm_medianfilter: BM bitmap_api::median_filter(BM bm = , int sx = 1, int sy = 1);
repeat: BM bitmap_api::repeat_bitmap(BM orig1 = , int x_count = 1, int y_xount = 1);
flip_x: BM bitmap_api::flip_x(BM orig = );
flip_y: BM bitmap_api::flip_y(BM orig = );
rot90: BM bitmap_api::rot90(BM orig = );
indicator: BM bitmap_api::Indicator(int sx = 256, int sy = 256, int g_ind = 0);
noise_vec: BM bitmap_api::noise_vectors(int sx = 256, int sy = 256);
gradient: BM bitmap_api::gradient(PT pos_1 = ev.point_api.point(0.0,0.0,0.0), PT pos_2 = ev.point_api.point(0.0, 100.0, 0.0), unsigned int color_1 = ffffffff, unsigned int color_2 = ff888888, int sx = 100, int sy = 100);
chessboard: BM bitmap_api::chessboard(int tile_sx = 10, int tile_sy = 10, int count_x = 8, int count_y = 8, unsigned int color_1 = ffffffff, unsigned int color_2 = ff888888);
mandelbrot: BM bitmap_api::mandelbrot(bool is_julia = false, float start_x = -2.0, float end_x = 1.0, float start_y = -1.0, float end_y = 1.0, float xx = 0.0, float yy = 0.0, int sx = 256, int sy = 256, int count = 64);
blur: BM bitmap_api::simple_blur(BM bm = , float center = 0.5, float left = 0.125, float right = 0.125, float top = 0.125, float bottom = 0.125);
baked_shadow: BM bitmap_api::calculate_baked_light(P texture_p = , P scene_p = , BM texture = , int count = 10000, float light_pos_x = -300.0, float light_pos_y = 300.0, float light_pos_z = -300.0, float shadow_darkness = 0.2, float softness = 50.0);
bm_bumpmap: BM bitmap_api::bump_map(FB fb = , float h = 10.0);
bm_memoize: BM bitmap_api::memoize(BM bm = );
bm_world_from_bitmap: BM bitmap_api::world_from_bitmap3(EveryApi& ev = ev, [BM] v = , std::string url = http://tpgames.org/map.txt, std::string chars = .#, int dx = 100, int dy = 100);
bm_persistent_cache: BM bitmap_api::persistent_cache(BM bm = , std::string filename = cache.ppm);
cbm_empty: CBM cont_bitmap_api::cbm_empty(float sx = 1.0, float sy = 1.0);
cbm_from_bitmap: CBM cont_bitmap_api::from_bitmap(BM bm = , float xsize = 1.0, float ysize = 1.0);
cbm_to_bitmap: BM cont_bitmap_api::to_bitmap(CBM cbm = , int sx = 200, int sy = 200);
cbm_bicubic: CBM cont_bitmap_api::bicubic(float f_0 = 0.0, float f_1 = 0.0, float df_0 = 0.5, float df_1 = -0.5, float ff_0 = 1.0, float ff_1 = 1.0, float dff_0 = 0.5, float dff_1 = -0.5);
cbm_sample: BM cont_bitmap_api::sample(CBM cbm = , int sx = 200, int sy = 200);
cbm_rotate: CBM cont_bitmap_api::rotate(CBM cbm = , float center_x = 0.5, float center_y = 0.5, float angle = 0.0);
s_spherical: S polygon_api::s_spherical(float c_x = 0.0, float c_y = 0.0, float c_z = 0.0, FB fb = , float start_radius = 300, float end_radius = 350, float start_values = 0.0, float end_values = 1.0);
s_bitmap: S surface_api::texture(S orig = , BM texture = );
s_sample: P polygon_api::s_sample(S surf = , int sx = 300, int sy = 300);
cfb_c: CFB float_bitmap_api::C_bitmap(float sx = 100.0, float sy = 100.0, float C = 1.0);
cfb_x: CFB float_bitmap_api::X_bitmap(float sx = 300.0, float sy = 300.0);
cfb_y: CFB float_bitmap_api::Y_bitmap(float sx = 300.0, float sy = 300.0);
cfb_add: CFB float_bitmap_api::AddBitmap([CFB] vec = );
cfb_mul: CFB float_bitmap_api::MulBitmap([CFB] vec = );
cfb_sqrt: CFB float_bitmap_api::SqrtContFloat(CFB val = );
cfb_sin: CFB float_bitmap_api::Sin(CFB val = );
cfb_cos: CFB float_bitmap_api::Cos(CFB val = );
cfb_tan: CFB float_bitmap_api::Tan(CFB val = );
cfb_sample: FB float_bitmap_api::SampleContFloat(CFB bm = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, int sx = 100, int sy = 100, float mult = 1.0);
cfb_equalizer: CBB float_bitmap_api::Equalizer(CFB a1 = , CFB a2 = );
cbb_sample: BB float_bitmap_api::SampleContBool(CBB bm = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, int sx = 100, int sy = 100);
empty: P polygon_api::p_empty();
save_model: ML polygon_api::save_model_ml(P poly = , std::string filename = test.obj);
save_ds: ML mainloop_api::save_ds_ml(EveryApi& ev = ev, std::string out_filename = test.ds, P poly = );
p_url: P polygon_api::p_url(EveryApi& ev = ev, std::string url = http://tpgames.org/example.obj, int count = 10);
p_mtl: P polygon_api::p_mtl(EveryApi& ev = ev, std::string obj_url = http://tpgames.org/sponza/sponza.obj, std::string mtl_url = http://tpgames.org/sponza/sponza.mtl, std::string url_prefix = http://tpgames.org/sponza, int count = 1);
p_url_mtl: P polygon_api::p_url_mtl(EveryApi& ev = ev, std::string url = http://tpgames.org/example.obj, int count = 10, [std::string] material_names = );
p_ds_url: P polygon_api::p_ds_url(EveryApi& ev = ev, std::string url = http://tpgames.org/sponza.ds);
p_stl: P polygon_api::stl_load(std::string url = http://tpgames.org/teapot.stl);
p_gltf: P polygon_api::gltf_load(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb, int mesh_index = 0, int prim_index = 0);
p_alt: P polygon_api::alt([P] vec = , int index = 0);
p_array: [P] polygon_api::poly_array([P] vec = );
triangle: P polygon_api::triangle(PT p1 = , PT p2 = , PT p3 = );
to_triangles: P polygon_api::quads_to_triangles(P p = );
quad: P polygon_api::quad(PT p1 = , PT p2 = , PT p3 = , PT p4 = );
quad_x: P polygon_api::quad_x(float x = 0.0, float y1 = 0.0, float y2 = 100.0, float z1 = 0.0, float z2 = 100.0);
quad_y: P polygon_api::quad_y(float x1 = 0.0, float x2 = 100.0, float y = 0.0, float z1 = 0.0, float z2 = 100.0);
quad_z: P polygon_api::quad_z(float x1 = 0.0, float x2 = 100.0, float y1 = 0.0, float y2 = 100.0, float z = 0.0);
quad_fullscreen: P polygon_api::fullscreen_quad(EveryApi& ev = ev);
vr_fullscreen_quad: P polygon_api::vr_fullscreen_quad(EveryApi& ev = ev, bool is_right_eye = false);
polygon: P polygon_api::polygon3(PTS vec = );
cube: P polygon_api::cube(float start_x = -100.0, float end_x = 100.0, float start_y = -100.0, float end_y = 100.0, float start_z = -100.0, float end_z = 100.0);
rounded_cube: P polygon_api::rounded_cube(EveryApi& ev = ev, float start_x = -100.0, float end_x = 100.0, float start_y = -100.0, float end_y = 100.0, float start_z = -100.0, float end_z = 100.0, float r_radius = 20.0);
sphere: P polygon_api::sphere(PT center = (0.0,0.0,0.0), float radius = 100.0, int numfaces1 = 30, int numfaces2 = 30);
plane_map: P polygon_api::plane_map(float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float start_z = 0.0, float end_z = 70.0, float start_values = 0.0, float end_values = 1.0, FB fb = , int sx = 256, int sy = 256);
sphere_map: P polygon_api::sphere_map(float c_x = 0.0, float c_y = 0.0, float c_z = 0.0, FB fb = , float start_radius = 200.0, float end_radius = 250.0, float start_values = 0.0, float end_values = 1.0, int sx = 30, int sy = 30);
shadow_map: BM polygon_api::shadow_map(EveryApi& ev = ev, P p = , float p_x = 0.0, float p_y = 0.0, float p_z = 0.0, int sx = 512, int sy = 512);
shadow_map2: BB polygon_api::shadow_map2(P p = , float p_x = 0.0, float p_y = -300.0, float p_z = 0.0, int sx = 100, int sy = 100, P quad = );
shadow_map3: BM polygon_api::shadow_map3(EveryApi& ev = ev, P objs = , float p_x = 0.0, float p_y = -300.0, float p_z = 0.0, int sx = 100, int sy = 100, P quad = );
disc: P polygon_api::disc(EveryApi& ev = ev, int numfaces = 30, float center_x = 0.0, float center_y = 0.0, float center_z = 0.0, float normal_x = 0.0, float normal_y = 0.0, float normal_z = 1.0, float radius = 100.0);
cone: P polygon_api::cone(int numfaces = 30, PT p1 = (0.0,0.0,0.0), PT p2 = (0.0,100.0,0.0), float radius1 = 30.0, float radius2 = 10.0);
torus: P polygon_api::torus2(EveryApi& ev = ev, int numfaces1 = 20, int numfaces2 = 20, PT center = , float radius1 = 250.0, float radius2 = 50.0);
bar_chart: P polygon_api::bar_chart(EveryApi& ev = ev, std::string url = http://tpgames.org/test_bar.txt, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = 0.0, float end_z = 40.0, float per = 80.0);
bar_chart2: P polygon_api::bar_chart2(EveryApi& ev = ev, std::string url = http://tpgames.org/test_bar2.txt, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0, float per = 80.0, float per2 = 80.0);
pie_chart: P polygon_api::p_piechart(EveryApi& ev = ev, float c_x = 0.0, float c_y = 0.0, float start_angle = 1.0, float end_angle = 3.0, float radius = 100.0, int numsteps = 30, float start_z = 0.0, float end_z = 30.0);
p_or_elem: P polygon_api::or_elem(P p1 = , P p2 = );
p_or_array: P polygon_api::or_array2([P] vec = );
p_mix: P polygon_api::mix_mesh(P p = , PTS pts = , float val = 0.5);
translate: P polygon_api::translate(P orig = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
rotatex: P polygon_api::rotatex(P orig = , float angle = 0.0);
rotatey: P polygon_api::rotatey(P orig = , float angle = 0.0);
rotatez: P polygon_api::rotatez(P orig = , float angle = 0.0);
scale: P polygon_api::scale(P orig = , float sx = 1.0, float sy = 1.0, float sz = 1.0);
towards_notmal: P lines_api::p_towards_normal(P p = , float amount = 0.5);
lod_choose: P polygon_api::lod_choose([P] vec = , std::string name = lod);
lod_set: P polygon_api::lod_set(P p = , std::string name = lod, int value = 0);
lod_select: IF polygon_api::lod_select(float start_dist = 0.0, float dist_step = 300.0, int max_value = 3);
mesh_resize: P polygon_api::mesh_resize(P p = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0);
fix_vertex_order: P polygon_api::fix_vertex_order(P p = );
filter_invisible: P polygon_api::filter_invisible(P p = , float size = 1.0);
p_repeat_xy: P polygon_api::repeat_xy_p(EveryApi& ev = ev, P p = , float start_x = 0.0, float start_y = 0.0, float dx = 30.0, float dy = 30.0, int sx = 10, int sy = 10);
p_repeat_xz: P polygon_api::repeat_xz_p(EveryApi& ev = ev, P p = , float start_x = 0.0, float start_z = 0.0, float dx = 30.0, float dz = 30.0, int sx = 10, int sz = 10);
p_repeat_yz: P polygon_api::repeat_yz_p(EveryApi& ev = ev, P p = , float start_y = 0.0, float start_z = 0.0, float dy = 30.0, float dz = 30.0, int sy = 10, int sz = 10);
deform: P polygon_api::deform(P obj = , O bools = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
linear_span: P polygon_api::linear_span(EveryApi& ev = ev, LI li = , float dx = 0.0, float dy = 0.0, float dz = 100.0, int num_steps = 1);
li_to_cone: P polygon_api::line_to_cone(EveryApi& ev = ev, LI li = , float size = 10.0, int numfaces = 15);
curve_to_poly: P polygon_api::curve_to_poly(C curve = , float start_x = -4.0, float end_x = 4.0, float start_y = -2.0, float end_y = 2.0, float start_angle = 1.2, float end_angle = 7.48318, int numinstances = 120);
static_instancing: P polygon_api::static_instancing(EveryApi& ev = ev, P obj = , PTS pos = );
inst_vertex_color: P polygon_api::static_instancing_vertex_color(EveryApi& ev = ev, P obj = , PTS pos = );
static_inst_color: P polygon_api::static_instancing_with_color(EveryApi& ev = ev, P obj = , BM bm = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float z = 0.0);
color_map: P polygon_api::color_map(BM bm = , float statt_x = -200, float end_x = 200, float start_y = -200, float end_y = 200, float z = 0);
color_map3: P polygon_api::color_map3(BM bm = , FB fb = , float sx = 100, float sy = 100, float z = 0);
color_map3_cyl: P polygon_api::color_map3_cyl(BM bm = , FB fb = , float sx = 100, float sy = 100, float z = 0);
color_map3_sph: P polygon_api::color_map3_sph(BM bm = , FB fb = , float sx = 100, float sy = 100, float z = 0);
color: P polygon_api::color(P orig = , unsigned int color = ffffffff);
p_mix_color: P polygon_api::mix_color(P orig = , P orig2 = , float val = 0.5);
p_min_color: P polygon_api::min_color(P orig = , P orig2 = );
p_max_color: P polygon_api::max_color(P orig = , P orig2 = );
color_faces: P polygon_api::color_faces(P orig = , unsigned int color_1 = ffffffff, unsigned int color_2 = ffffffff, unsigned int color_3 = ff888888, unsigned int color_4 = ff888888);
color_alpha: P polygon_api::color_alpha(P orig = , unsigned int alpha = ff);
color_from_normals: P polygon_api::color_from_normals(P orig = );
color_from_texcoord: P polygon_api::color_from_texcoord(P orig = , unsigned int color_tl = ffff8844, unsigned int color_tr = ff884422, unsigned int color_bl = ffaa8844, unsigned int color_br = ffffffff);
color_darkness: P polygon_api::normal_darkness(P p = , float dark = 1.0);
color_gradient: P polygon_api::gradient_color(P p = , float p_x = 0.0, float p_y = -300.0, float p_z = 0.0, float v_x = 0.0, float v_y = 600.0, float v_z = 0.0, unsigned int start_color = ff000000, unsigned int end_color = ffffffff);
color_distance: P polygon_api::color_distance(P model = , float center_x = 0.0, float center_y = 0.0, float center_z = 0.0, unsigned int color_center = ffffffff, unsigned int color_dist = ff000000, float dist_center = 10.0, float dist_dist = 300.0);
color_range: P polygon_api::color_range(P orig = , unsigned int source_upper = ffffffff, unsigned int source_lower = 00000000, unsigned int upper_range = ffffffff, unsigned int lower_range = 88888888);
color_lambert: P polygon_api::color_lambert(P orig = , unsigned int color = ff884422, float light_dir_x = -2.0, float light_dir_y = 1.0, float light_dir_z = 2.0, float pow = 1.0, float intensity = 0.3);
recalc_normals: P polygon_api::recalculate_normals(P orig = );
smooth_normals: P polygon_api::smooth_normals2(P orig = );
spherical_normals: P polygon_api::spherical_normals(P p = , float p_x = 0.0, float p_y = 0.0, float p_z = 0.0);
flip_normals: P polygon_api::flip_normals(P orig = );
p_offsets: P polygon_api::build_offsets(P orig = , [PT] vec = );
color_grayscale: P polygon_api::color_grayscale(P orig = );
choose_texture: P polygon_api::choose_texture(P orig = , int tex = 0);
texcoord: P polygon_api::texcoord_manual(P orig = , float p1_x = 0.0, float p1_y = 0.0, float p2_x = 1.0, float p2_y = 0.0, float p3_x = 1.0, float p3_y = 1.0, float p4_x = 0.0, float p4_y = 1.0);
texcoord_plane: P polygon_api::texcoord_plane(P orig = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0);
texcoord_from_normal: P polygon_api::from_normal_to_texcoord(P p = );
texcoord_subarea: P polygon_api::texcoord_subarea(P p = , float start_x = 0.0, float end_x = 0.5, float start_y = 0.0, float end_y = 0.5);
texcoord_spherical: P polygon_api::texcoord_spherical2(EveryApi& ev = ev, PT center = , float r = 100.0, P orig = );
p_tex_splitter: P polygon_api::texture_splitter(P obj = , int start_index = 0, int end_index = 16);
p_tex_storage: P polygon_api::texture_storage(P obj = , int texture_sx = 1024, int texture_sy = 1024);
p_tex_light: P polygon_api::light_transport(P obj = , int num = 10000, float light_dir_x = 1.0, float light_dir_y = 1.0, float light_dir_z = 1.0);
texture_from_p: BM polygon_api::texture_from_p(P obj = , int num = 0);
p_tex_replace: P polygon_api::replace_texture(P obj = , BM bm = , int num = 0);
log_coords: P polygon_api::log_coords2(P p = , int x_count = 5, int y_count = 5, float sx = 30.0, float sy = 30.0, float sz = 30.0);
sph_wave: P polygon_api::spherical_wave(P p = , float r1 = 30.0, float freq_1 = 1.0, float r2 = 30.0, float freq_2 = 3.0);
splitquads: P polygon_api::splitquads(P p = , int x_count = 5, int y_count = 5);
shadow: P polygon_api::shadow(P orig = , PT pos = (0.0,0.0,0.0), V u_x = (1.0,0.0,0.0), V u_y = (0.0,0.0,1.0), V light_vec = (1.0,1.0,1.0));
reflection: P polygon_api::reflection(P orig = , PT pos = (0.0,0.0,0.0), V u_x = (1.0,0.0,0.0), V u_y = (0.0,0.0,1.0), V light_vec = (0.0, 1.0,0.0));
subpoly_change: P polygon_api::subpoly_change(P p = , P p2 = , O o = );
memoize: P polygon_api::memoize(P orig = );
persistent_cache: P polygon_api::persistent_cache(P p = , std::string filename = cache.obj);
world_from_bitmap: P polygon_api::world_from_bitmap(EveryApi& ev = ev, [P] pieces = , std::string filename = map.txt, std::string chars = .0123456789, float dx = 100.0, float dy = 100.0, int sx = 5, int sy = 5);
p_to_bitmap: BM polygon_api::renderpolytobitmap(EveryApi& ev = ev, P p = , SH sh = , float x = 0.0, float y = 0.0, float z = 0.0, int sx = 800, int sy = 600);
p_wave: ML polygon_api::wave_shader(EveryApi& ev = ev, ML mainloop = , float radius = 0.02, float t_mult = 1.5, float x_mult = 17, float y_mult = 9);
p_fog: ML polygon_api::fog_shader(EveryApi& ev = ev, ML mainloop = , float fog_dist = 300.0, unsigned int dark_color = ff000000, unsigned int light_color = ffffffff);
shader: SH shader_api::shader_choice(EveryApi& ev = ev, int choose = 0);
emptybool: BB bool_bitmap_api::bb_empty(int sx = 100, int sy = 100);
bb_from_bitmap: BB bool_bitmap_api::from_bitmaps_color(BM bm = , int r = 255, int g = 255, int b = 255);
from_float_bitmap: BB bool_bitmap_api::from_float_bitmap(FB float_bm = , float range_start = 0.5, float range_end = 1.0);
line: BB bool_bitmap_api::line(BB bg = , float p_x = 0.0, float p_y = 0.0, float p2_x = 100.0, float p2_y = 100.0, float line_width1 = 3.0, float line_width2 = 3.0);
tri: BB bool_bitmap_api::tri(BB orig = , float p1_x = 0, float p1_y = 0, float p2_x = 100, float p2_y = 30, float p3_x = 50, float p3_y = 100);
circle: BB bool_bitmap_api::circle(BB bg = , float center_x = 50.0, float center_y = 50.0, float radius = 50.0);
rectangle: BB bool_bitmap_api::rectangle(BB bg = , float x = 0.0, float y = 0.0, float width = 30.0, float height = 30.0);
part_circle: BB bool_bitmap_api::part_circle(int sx = 100, int sy = 100, float x = 50.0, float y = 50.0, float start_angle = 0.0, float end_angle = 1.0, float start_rad = 30.0, float end_rad = 50.0);
rings: BB bool_bitmap_api::rings(int sx = 300, int sy = 300, float center_x_start = 150, float center_y_start = 150, float center_x_end = 150, float center_y_end = 150, float start_radius = 10, float end_radius = 180, float start_thickness = 30, float end_thickness = 30, int numrings = 20);
not_bitmap: BB bool_bitmap_api::not_bitmap(BB b = );
andnot_bitmap: BB bool_bitmap_api::andnot_bitmap(BB b1 = , BB not_b2 = );
or_bitmap: BB bool_bitmap_api::or_bitmap(BB b1 = , BB b2 = );
xor_bitmap: BB bool_bitmap_api::xor_bitmap(BB b1 = , BB flip_b2 = );
choose_bitmap: BB bool_bitmap_api::choose_bitmap(BB bools = , BB true_bm = , BB false_bm = );
bb_sprite: BB bool_bitmap_api::sprite(BB bg = , BB sprite = , float x = 0.0, float y = 0.0, float mult_x = 1.0, float mult_y = 1.0);
to_bitmap: BM bool_bitmap_api::to_bitmap(BB bools = , int true_r = 255, int true_g = 255, int true_b = 255, int true_a = 255, int false_r = 0, int false_g = 0, int false_b = 0, int false_a = 0);
fb_dither: BB bool_bitmap_api::black_white_dithering(FB float_bitmap = );
bb_ibm: IBM bitmap_api::create_ibm([BB] vec = );
ibm_bb: BB bitmap_api::choose_bool(IBM bm = , int val = 1);
ibm_bbs: [BB] bitmap_api::choose_ints(IBM bm = , int count = 2);
emptyfloat: FB float_bitmap_api::fb_empty(int sx = 100, int sy = 100);
from_red: FB float_bitmap_api::from_red(BM color_bm = );
from_green: FB float_bitmap_api::from_green(BM color_bm = );
from_blue: FB float_bitmap_api::from_blue(BM color_bm = );
from_alpha: FB float_bitmap_api::from_alpha(BM color_bm = );
gradient_fb: FB bitmap_api::gradient_fb(int sx = 100, int sy = 100, float val = 0.0, float val2 = 1.0, bool flip = false);
radial_fb: FB bitmap_api::radial_fb(int sx = 100, int sy = 100, float x = 50, float y = 50, float r = 50, float val_at_zero = 1.0, float val_at_r = 0.0);
sin_fb: FB bitmap_api::sin_fb(FB gradient = );
plus_fb: FB bitmap_api::plus_fb(FB f1 = , FB f2 = );
mul_fb: FB bitmap_api::mul_fb(FB f = , float mul = 1.0);
bm_dist: FB float_bitmap_api::dist(int sx = 100, int sy = 100, float p_x = 50.0, float p_y = 50.0);
bm_blur: FB float_bitmap_api::blur_bitmap(FB fb = , float d = 0.5);
bm_gaussian: FB float_bitmap_api::gaussian(float start_x = 0.0, float end_x = 100.0, float start_y = 0.0, float end_y = 100.0, float start_z = 0.0, float end_z = 1.0, int sx = 100, int sy = 100);
bm_perlin: FB float_bitmap_api::perlin_noise(FB grad_1 = , FB grad_2 = );
to_grayscale_color: BM float_bitmap_api::to_grayscale_color(FB fb = , int r = 255, int g = 255, int b = 255, int a = 255, int r2 = 0, int g2 = 0, int b2 = 0, int a2 = 0);
fb_choose_bitmap: BM float_bitmap_api::choose_bitmap(FB fb = , BM bm1 = , BM bm2 = );
from_bool: FB float_bitmap_api::from_bool(BB b = , float val_true = 1.0, float val_false = 0.0);
distance_field: FB float_bitmap_api::distance_field(FB fb = , float max_value = 100.0);
add_border: FB float_bitmap_api::add_border(FB fb = );
load_map: IBM bitmap_api::intbitmap_loader(std::string url = http://tpgames.org/examplemap.txt);
ibm_to_bm: BM bitmap_api::intbitmap_bm(IBM ibm = );
fb_to_ibm: IBM bitmap_api::convert_fb_to_ibm_bitmap(FB fb = , float start = 0.0, float d = 0.3);
ibm_to_vx: VX bitmap_api::convert_ibm_to_vx(IBM bm = );
m_def: MT materials_api::m_def(EveryApi& ev = ev);
m_colour: MT materials_api::colour_material(EveryApi& ev = ev, float mix = 0.5);
m_texture: MT materials_api::texture(EveryApi& ev = ev, BM bm = , float mix = 1.0);
m_texture_id: MT materials_api::textureid(EveryApi& ev = ev, TXID txid = , float mix = 1.0);
m_texture_many: MT materials_api::texture_many(EveryApi& ev = ev, [BM] vec = , float mix = 1.0);
m_texture_many_p: MT materials_api::texture_many2(EveryApi& ev = ev, float mix = 0.5);
m_mtl_many: MT materials_api::many_texture_id_material(EveryApi& ev = ev, std::string mtl_url = http://tpgames.org/sponza/sponza.mtl, std::string url_prefix = http://tpgames.org/sponza, float mix = 1, int start_range = 0, int end_range = 15);
m_texture_cubemap: MT materials_api::texture_cubemap(EveryApi& ev = ev, [BM] vec = , float mix = 1.0, float mix2 = 1.0);
m_texture_arr: MT materials_api::texture_arr(EveryApi& ev = ev, [BM] vec = , int sx = 256, int sy = 256, float mix = 1.0);
m_skeletal: MT materials_api::skeletal(EveryApi& ev = ev);
m_shading1: MT materials_api::shading1(EveryApi& ev = ev, MT nxt = , float mix_val1 = 0.95, float mix_val2 = 0.5);
m_shading2: MT materials_api::shading2(EveryApi& ev = ev, MT nxt = , unsigned int color1 = ffaaaaaa, unsigned int color2 = ffeeeeee, unsigned int color3 = ffffffff);
m_phong: MT materials_api::phong(EveryApi& ev = ev, MT nxt = , float light_dir_x = -0.3, float light_dir_y = 0.3, float light_dir_z = -1.0, unsigned int ambient = ffff8800, unsigned int highlight = ff666666, float pow = 5.0);
m_gltf: MT materials_api::gltf_material(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb, int material_id = 0, float mix = 1.0);
m_gltf_env: MT materials_api::gltf_material_env(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb, int material_id = 0, float mix = 1.0, BM diffuse = , BM specular = , BM bfrd = );
m_material: MT materials_api::gltf_material3(EveryApi& ev = ev, float roughness = 0.5, float metallic = 0.8, float base_r = 1.0, float base_g = 1.0, float base_b = 1.0, float base_a = 1.0, float mix = 1.0);
m_bump_phong: MT materials_api::bump_phong(EveryApi& ev = ev, float light_dir_x = -0.3, float light_dir_y = 0.3, float light_dir_z = -1.0, unsigned int ambient = ffff8800, unsigned int highlight = ffffffff, float pow = 10.0, FB fb = , float bump_width = 5.0);
m_fog: MT materials_api::fog(EveryApi& ev = ev, MT nxt = , float dist = 300.0, unsigned int dark_color = ff000000, unsigned int light_color = ffffffff);
m_gi: MT materials_api::gi(EveryApi& ev = ev, MT nxt = , PTS pts = , float obj_size = 100.0);
m_fade: MT materials_api::fade(EveryApi& ev = ev, MT next = , float start_time = 0.0, float end_time = 10.0, float start_time2 = 30.0, float end_time2 = 40.0);
m_or_elem: MT materials_api::combine_materials(EveryApi& ev = ev, MT mat1 = , MT mat2 = );
m_shadow: MT materials_api::shadow(EveryApi& ev = ev, P p = , [BM] vec = , float p_x = 0.0, float p_y = 0.0, float p_z = 0.0, int sx = 512, int sy = 512, unsigned int dark_color = ff000000, float mix = 1.0, float mix2 = 0.5);
m_shadow2: MT materials_api::shadow2(EveryApi& ev = ev, P p = , float p_x = 0.0, float p_y = 0.0, float p_z = 0.0, int sx = 512, int sy = 512, unsigned int dark_color = ff000000, float mix = 1.0, float mix2 = 0.5, int numtextures = 0);
m_dyn_lights: MT materials_api::dyn_lights(EveryApi& ev = ev, MT nxt = , float light_pos_x = 0.0, float light_pos_y = 0.0, float light_pos_z = 0.0, float dist = 500.0, int dyn_point = -1);
m_snow: MT materials_api::snow(EveryApi& ev = ev, MT nxt = , unsigned int color1 = ffaaaaaa, unsigned int color2 = ffeeeeee, unsigned int color3 = ffffffff, float mix_val = 0.95);
m_flat: MT materials_api::flat(EveryApi& ev = ev, MT nxt = , unsigned int color1 = ff8888ff, unsigned int color2 = ffff4422, unsigned int color3 = ffffffff);
m_fur: MT materials_api::fur(EveryApi& ev = ev, MT nxt = , PT center = , float dist = 60.0, float max_angle = 1.59, int count = 1500, float size = 2.0, int cone_numfaces = 4);
m_noise: MT materials_api::noise(EveryApi& ev = ev, int sx = 1024, int sy = 1024, int r = 255, int g = 255, int b = 255, int a = 255, int r2 = 0, int g2 = 0, int b2 = 0, int a2 = 255, float mix = 0.5);
m_bloom: MT materials_api::bloom(EveryApi& ev = ev, MT nxt = , BM bm = , float r_cut = 0.7, float g_cut = 0.7, float b_cut = 0.7, float pixel_x = 0.01, float pixel_y = 0.01);
m_choose_color: MT materials_api::choose_color(EveryApi& ev = ev, MT nxt = , unsigned int color = ffff8844, float mix_val = 0.5);
m_brashmetal: MT materials_api::brashmetal(EveryApi& ev = ev, MT nxt = , int count = 80000, bool web = true);
m_marble: MT materials_api::marble(EveryApi& ev = ev, MT nxt = , int count = 300, float cubesize = 10);
m_web: MT materials_api::web(EveryApi& ev = ev, MT nxt = , float mult = 1.03, float linewidth = 2.0, unsigned int linecolor = ff000000);
m_bevel: MT materials_api::bevel(EveryApi& ev = ev, MT nxt = , float dir = -1.5, float linewidth = 2.0);
m_dist_field: MT materials_api::dist_field_mesh(EveryApi& ev = ev, SFO sfo = , MT mt = );
m_dist_field_color: MT materials_api::mesh_color_from_sfo(EveryApi& ev = ev, SFO sfo = , MT mt = );
sbm_many_texture: SBM polygon_api::texture_sbm();
sbm_circle: SBM polygon_api::sbm_circle(float start_time = 0.0, float end_time = 100.0, float start_pos_x = 0.0, float start_pos_y = 0.0, float end_pos_x = 0.0, float end_pos_y = 0.0, float start_radius = 100.0, float end_radius = 120.0);
sbm_blur: SBM polygon_api::blur_sbm(SBM texture = , float pixel_x = 0.01, float pixel_y = 0.01);
sbm_bloom_cut: SBM polygon_api::bloom_cut_sbm(SBM texture = , float r_cut = 0.7, float g_cut = 0.7, float b_cut = 0.7);
sbm_combine: SBM polygon_api::combine_sbm(SBM texture1 = , SBM texture2 = );
sfo_sbm: SBM polygon_api::sfo_sbm(EveryApi& ev = ev, SFO sfo = );
p_sbm: ML polygon_api::sbm_texture(EveryApi& ev = ev, ML mainloop = , SBM bitmap = );
li_points: LI lines_api::point_array([PT] arr = );
li_from_pts: LI points_api::li_from_pts(PTS pts1 = , float dx = 0.0, float dy = 0.01, float dz = 0.0);
li_to_pts: PTS points_api::li_pts(LI li = , float pos = 0.0);
li_to_pts2: PTS points_api::li_pts2(LI li = );
change_color: LI lines_api::change_color(LI li = , unsigned int color = ffffffff);
change_color2: LI lines_api::change_color(LI li = , unsigned int color_1 = ffffffff, unsigned int color_2 = ff888888);
li_from_polygon: LI lines_api::from_polygon(P poly = );
li_polygon: P polygon_api::li_polygon(LI li = , float width = 2.0);
li_bevel: LI lines_api::li_bevel(LI li = , P p = , float mix = 0.5);
li_fur: LI lines_api::fur(PTS pts = , PT center = , float dist = 10.0);
li_rand_angle: LI lines_api::random_angle(LI lines = , float max_angle = 0.3);
li_from_quads: LI lines_api::random_mesh_quad_lines(EveryApi& ev = ev, P p = , int count = 1000);
li_grid_from_quads: LI lines_api::lines_from_quads(P p = , int sx = 5, int sy = 5);
border_from_bool_bitmap: LI lines_api::border_from_bool_bitmap(BB b = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float z = 0.0);
li_translate: LI lines_api::translate(LI lines = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
li_scale: LI lines_api::scale(LI lines = , float m_x = 1.0, float m_y = 1.0, float m_z = 1.0);
li_or_elem: LI lines_api::li_or_elem(LI li1 = , LI li2 = );
li_product: P lines_api::line_product(LI li1 = , LI li2 = );
li_split: LI lines_api::split_lines(LI li = , float dist = 5.0);
li_twist: LI lines_api::twist_y(LI li = , float y_0 = 0.0, float angle_per_y_unit = 0.031459);
li_update: ML lines_api::update_ml(LLA lla = , LI li = );
c_line: C curve_api::line(PT p1 = , PT p2 = );
c_circle_xy: C curve_api::circle_xy(PT center = , float r = 100.0);
c_circle_xz: C curve_api::circle_xz(PT center = , float r = 100.0);
c_circle_wave: C curve_api::circle_xy_wave(float start_r = 200.0, float end_r = 220.0, WV wave = , float length = 6.283);
c_linear: C curve_api::linear([PT] vec = );
c_bezier: C curve_api::bezier([PT] vec = );
c_scale: C curve_api::scale(C curve = , float sx = 1.0, float sy = 1.0, float sz = 1.0);
c_trans: C curve_api::trans(C curve = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
c_compose: C curve_api::compose([C] vec = );
c_change_length: C curve_api::change_length(C curve = , float new_legnth = 1.0);
c_split: C curve_api::split(C curve = , float start = 0.0, float end = 1.0);
c_sample: PTS curve_api::sample(C curve = , int num_samples = 10);
c_render: LI curve_api::to_lines(C curve = , int num_lines = 40);
c_product: PA curve_api::curve_product(C c1 = , C c2 = , PT point = );
cg_lines: CG curve_api::curve_group_from_lines(LI li = );
cg_to_li: LI curve_api::lines_from_curve_group(CG curvegroup = , int split = 3);
ma_p: MA polygon_api::meshanim([P] vec = , float start_time = 0.0, float end_time = 10.0);
ma_to_p: P polygon_api::meshanim_mesh(MA anim = , float time = 0.0);
ma_render: ML polygon_api::anim(EveryApi& ev = ev, ML next = , MA anim = , float start_time = 0.0, float end_time = 10.0, int count = 3);
ma_bind: ML polygon_api::anim_bind(EveryApi& ev = ev, ML next = , MA anim = , MT material = , float start_time = 0.0, float end_time = 10.0, int count = 3);
ma_to_cg: CG polygon_api::curve_group_from_anim(MA meshanim = , float start_time = 0.0, float end_time = 100.0);
pa_sample: P curve_api::patch_sample(PA patch = , int sx = 10, int sy = 10);
pa_x: C curve_api::x_curve(PA patch = , float y = 0.0);
pa_y: C curve_api::y_curve(PA patch = , float x = 0.0);
cpp_sum: CPP curve_api::xy_sum();
cpp_sum2: CPP curve_api::xy_sum2(float xmult = 1.0, float ymult = 1.0, float zmult = 1.0);
pt_array: PTS points_api::pt_array(EveryApi& ev = ev, [PT] vec = );
from_float_volume: PTS points_api::from_float_volume(FO volume = , int numpoints = 1000, float start_x = 0.0, float start_y = 0.0, float start_z = 0.0, float end_x = 100.0, float end_y = 100.0, float end_z = 100.0);
or_points: PTS points_api::or_points(PTS p1 = , PTS p2 = );
move_pts: PTS points_api::move(PTS obj = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
bullet_pts: PTS points_api::bullet(int key = 32, float vx = 30.0, float vy = 0.0, float vz = 0.0, float px = 0.0, float py = 0.0, float pz = 0.0, float dist = 600.0, int max_count = 15, float repeat_time = 200.0);
anim_mix_pts: PTS points_api::anim_mix(PTS obj1 = , PTS obj2 = , float start_val = 0.0, float end_val = 1.0, float start_time = 10.0, float end_time = 40.0);
score_hide_pts: PTS mainloop_api::score_hide_pts(PTS pts = );
score_set_hide: IF mainloop_api::score_set_hide();
sort_pts: PTS points_api::sort_pts(PTS points = );
rot_x_pts: PTS points_api::rot_x(PTS obj = , float angle = 1.570795);
rot_y_pts: PTS points_api::rot_y(PTS obj = , float angle = 1.570795);
rot_z_pts: PTS points_api::rot_z(PTS obj = , float angle = 1.570795);
anim_rot_pts: PTS points_api::anim_rot_pts(PTS pts = , float start_time = 0.0, float end_time = 100.0, float v_x = 0.0, float v_y = 1.0, float v_z = 0.0, float rotate_amount = 6.282);
scale_pts: PTS points_api::scale(PTS obj = , float sx = 1.0, float sy = 1.0, float sz = 1.0);
color_pts: PTS points_api::color_points(PTS p = , unsigned int color = ffffffff);
face_center: PTS points_api::polygon_face_center_points(P p = );
hemisphere_pts: PTS points_api::hemisphere_points(PT points = , V normal = , float r = 100.0, int numpoints = 100);
wave_pts: PTS points_api::wave_points(WV wave = , int num_samples = 50, float pos_x = -300.0, float pos_y = -300.0, float pos_z = 0.0, float u_x_x = 600.0, float u_x_y = 0.0, float u_x_z = 0.0, float u_y_x = 0.0, float u_y_y = 600.0, float u_y_z = 0.0);
filter_pts: PTS points_api::filter_component(PTS pts = , int comp = 2, float val = 0.0);
from_volume: PTS points_api::from_volume(O o = , PT pos = (0.0,0.0,0.0), V u_x = (100.0,0.0,0.0), V u_y = (0.0,100.0,0.0), V u_z = (0.0,0.0,100.0), int sx = 100, int sy = 100, int sz = 100);
shadow_points: PTS points_api::shadow_points(PTS obj = , PT pos = (0.0,0.0,0.0), V u_x = (100.0,0.0,0.0), V u_y = (0.0,0.0,100.0), V light_vec = (1.0,1.0,0.0));
random_plane: PTS points_api::random_plane(PT pos = , V u_x = , V u_y = , int numpoints = 100);
random_bitmap: PTS points_api::random_bitmap_instancing(EveryApi& ev = ev, BB bb = , int count = 300, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float z = 0.0);
random_quad: PTS points_api::random_mesh_quad_instancing(EveryApi& ev = ev, P p = , int count = 300);
random_volume: PTS volume_api::random_vol_object(O o = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0, int numpoints = 10000);
pts_grid: PTS points_api::pts_grid(BM bm = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float z = 0.0);
pts_grid_bb: PTS points_api::pts_grid_bb(BB bb = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float z = 0.0);
pts_memoize: PTS points_api::memoize_pts(PTS pts = );
pts_bounding_box: PTS points_api::collision_points(float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0);
pts_collision_bind: ML points_api::collision_bind(EveryApi& ev = ev, PTS bounding_box = , std::string name = obj1);
pts_coll_bind_inst: ML points_api::collision_bind_inst(EveryApi& ev = ev, PTS bounding_box = , PTS inst_points = , std::string name = obj1);
collidion_collect: ML points_api::collision_collect(ML mainloop = );
collision_seq_ml: ML mainloop_api::collision_seq_ml(ML curr = , ML end = , std::string obj1 = obj1, std::string obj2 = obj2, float show_duration = 100.0);
collision_gen_key: ML mainloop_api::collision_gen_key(ML curr = , std::string obj1 = obj1, std::string obj2 = obj2, int key = 32, float keypress_duration = 10.0);
ms_from_points: MS matrices_api::from_points(PTS pts = );
ms_mult: MS matrices_api::mult_array(MS m1 = , MS m2 = );
ms_random_rot: MS matrices_api::ms_random_rot(float px = 0.0, float py = 1.0, float pz = 0.0, int count = 30);
ms_subarray: MS matrices_api::subarray(MS ms = , int start = 0, int count = 0);
ms_from_lines_2d: MS matrices_api::from_lines_2d(LI li = );
ms_from_lines_3d: MS matrices_api::from_lines_3d(LI li = );
ms_static_inst: P polygon_api::static_instancing_matrix(EveryApi& ev = ev, P obj = , MS matrices = );
ms_lines_inst: LI polygon_api::li_static_instancing_matrix(EveryApi& ev = ev, LI obj = , MS matrices = );
ms_tree: MS tree_api::tree_ms(EveryApi& ev = ev, T tree = , float time = 0.0);
point: PT point_api::point(float x = 0.0, float y = 0.0, float z = 0.0);
move: PT point_api::move(PT p1 = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
mix: PT point_api::mix(PT p1 = , PT p2 = , float val = 0.5);
cmd_def: CMD move_api::default_cmds(float dx = 10.0, float dy = 10.0, float dz = 10.0);
cmd_repeat: CMD move_api::cmd_repeat(CMD cmds = , std::string repeat = .dd., float dx = 10.0, float dy = 10.0, float dz = 10.0);
cmd_rotate: CMD move_api::cmd_rotate(CMD cmds = , float v_x = 0.0, float v_y = 0.0, float v_z = 1.0, float angle = 0.0, float delta_angle = 1.57);
cmd_to_pts: PTS move_api::cmd_to_pts(CMD cmds = , std::string commands = .);
cmd_to_li: LI move_api::cmd_to_li(CMD cmds = , std::string commands = .);
cmd_to_plf: PLF move_api::cmd_to_plf(CMD cmds = , std::string commands = .);
vx_empty: VX voxel_api::empty_voxel(int sx = 30, int sy = 30, int sz = 30);
vx_sub: VX voxel_api::subvoxel(VX voxel = , int start_x = 0, int end_x = 100, int start_y = 0, int end_y = 100, int start_z = 0, int end_z = 100);
vx_landscape_bm: VX voxel_api::voxel_landscape_from_fbm(FB bitmap = , int height = 30, int false_val = -1, int true_val = 0);
vx_or_elem: VX voxel_api::blit_voxel2(VX v1 = , VX v2 = , int p_x = 0, int p_y = 0, int p_z = 0);
vx_blit: VX voxel_api::blit_voxel(O object = , int sx = 30, int sy = 30, int sz = 30, float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float start_z = -200.0, float end_z = 200.0, int false_value = -1, int true_value = 0);
vx_inst: [PTS] voxel_api::voxel_instancing(VX voxel = , int count = 1, float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float start_z = -200.0, float end_z = 200.0);
vx_render: ML voxel_api::voxel_render(EveryApi& ev = ev, [P] objs = , [PTS] ptss = );
vx_bind: ML voxel_api::voxel_bind(EveryApi& ev = ev, [P] objs = , [PTS] ptss = , MT mt = );
vx_static: P voxel_api::voxel_static(EveryApi& ev = ev, [P] objs = , [PTS] ptss = );
vx_p: VX voxel_api::convert_p_to_vx(P p = , int sx = 100, int sy = 100, int sz = 100, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0, int value = 0);
vx_im: VX voxel_api::from_implicit(IM im = , int sx = 100, int sy = 100, int sz = 100, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0, int value = 0);
av_from_pts: AV polygon_api::pts_to_voxel(PTS pts = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0, int sx = 30, int sy = 30, int sz = 30);
av_to_pts: PTS polygon_api::voxelarray_to_pts(AV att = , float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0);
av_unique: AV polygon_api::av_unique(AV arr = );
vector: V vector_api::vector(float dx = 0.0, float dy = 0.0, float dz = 0.0);
player: ML move_api::player(ML prev = );
enemy: ML move_api::enemy(ML prev = );
player_pos: ML move_api::player_pos(ML prev = , PT pos = );
enemy_pos: ML move_api::enemy_pos(ML prev = , PTS pos = );
plf_poly: P newplane_api::to_polygon(PLF faces = );
plf_reversefaces: PLF newplane_api::reverse_faces(PLF faces = );
triangulate2d: PLF newplane_api::triangulate(PLF faces = );
phy_empty: PH physics_api::phy_empty();
phy_anchor: PH physics_api::anchor_point2(PH phy = , PT pos = );
phy_force: PH physics_api::ext_force(PH phy = , int point = 0, V dir = );
phy_force_all: PH physics_api::ext_force_all(PH phy = , V dir = );
phy_link: PH physics_api::anchor_link(PH phy = , int p1 = 0, int p2 = 1, float dist = 100);
phy_object: PH physics_api::force_obj(PH phy = , O obj = , V dir = );
phy_p: PH physics_api::phy_from_p(P p = );
phy_points: PTS physics_api::physics_action(EveryApi& ev = ev, PH phy = );
dc_identity: DC move_api::identity();
dc_wave: DC move_api::wave(float r = 30.0, float speed1 = 1.0, float speed2 = 1.0, float dist1 = 30.0, float dist2 = 30.0, int sx = 30, int sy = 30);
dc_sphwave: DC move_api::sphwave(float r1 = 30.0, float fr_1 = 3.0, float t_1 = 1.0, float r2 = 30.0, float fr_2 = 5.0, float t_2 = 2.0);
dc_explosion: DC move_api::explosion(float center_x = 0.0, float center_y = 0.0, float center_z = 0.0, float start_val = 1.0, float end_val = 10.0, float start_time = 0.0, float end_time = 30.0);
dc_split: DC move_api::split(DC d1 = , DC d2 = , float val = 0.5);
o_from_bool_bitmap: O volume_api::from_bool_bitmap(BB b = , float dist = 50.0);
o_sphere: O volume_api::o_sphere(PT center = , float radius = 100.0);
o_cube: O volume_api::o_cube(float start_x = -100.0, float end_x = 100.0, float start_y = -100.0, float end_y = 100.0, float start_z = -100.0, float end_z = 100.0);
o_cone: O volume_api::o_cone(PT p1 = , PT p2 = , float rad1 = 100.0, float rad2 = 90.0);
o_torus: O volume_api::o_torus(PT center = , PT u_x = , PT u_y = , float dist1 = 100.0, float dist2 = 50.0);
o_mandelbrot: O volume_api::mandelbrot_volume(bool julia = false, int count = 64, float yy = 0.0);
o_mandelbulb: O volume_api::mandelbulb(float n = 2.5,, float p_x = 0.0, float p_y = 0.0, float p_z = 0.0, float c_x = 0.0, float c_y = 0.0, float c_z = 0.0, float radius = 100.0, int iterations = 64);
o_colour: O volume_api::colour(O object = , unsigned int color = ffffffff);
o_subset_color: O volume_api::subset_color(O model = , O color_subset = , unsigned int color = ffffffff);
o_move: O volume_api::move(O obj = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
o_rotatex: O volume_api::rotatex(O object = , float angle = 0.0);
o_rotatey: O volume_api::rotatey(O object = , float angle = 0.0);
o_rotatez: O volume_api::rotatez(O object = , float angle = 0.0);
o_scale: O volume_api::scale(O object = , float sx = 1.0, float sy = 1.0, float sz = 1.0);
o_notop: O volume_api::not_op(O object = );
o_minop: O volume_api::min_op(O object1 = , O object2 = );
o_maxop: O volume_api::max_op(O object1 = , O object2 = );
o_andnot: O volume_api::andnot_op(O object1 = , O not_obj = );
o_inst: O volume_api::instancing_volume(O volume = , PTS pts = );
im_sphere: IM implicit_api::im_sphere(float r = 100.0);
im_blob: IM implicit_api::blob(float c = 100.0, float c_x = 0.0, float c_y = 0.0, float cc_x = 60.0, float cc_y = 0.0);
im_translate: IM implicit_api::im_translate(IM obj = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
im_from_distance: IM implicit_api::from_distance(FD fd = , float pos_x = 0.0, float pos_y = 0.0, float pos_z = 0.0, float u_x = 300.0, float u_y = 300.0, float u_z = 300.0, float sx = 256.0, float sy = 256.0);
im_distance_cyl: IM implicit_api::from_distance_cyl(FD fd = , float pos_x = 0.0, float pos_y = 0.0, float pos_z = 0.0, float u_x = 300.0, float u_y = 300.0, float u_z = 300.0, float sx = 256.0, float sy = 256.0);
im_distance_sph: IM implicit_api::from_distance_sph(FD fd = , float pos_x = 0.0, float pos_y = 0.0, float pos_z = 0.0, float u_x = 300.0, float u_y = 300.0, float u_z = 300.0, float sx = 256.0, float sy = 256.0);
im_render_upper: FB implicit_api::render_upper(IM obj = , float size_x = 300.0, float size_y = 300.0, int sx = 255, int sy = 255, float dx = 0.5, float dy = 0.5);
im_render_lower: FB implicit_api::render_lower(IM obj = , float size_x = 300.0, float size_y = 300.0, int sx = 255, int sy = 255, float dx = 0.5, float dy = 0.5);
im_upper_color: BM implicit_api::render_upper_color(IM obj = , float size_x = 300.0, float size_y = 300.0, int sx = 255, int sy = 255, float dx = 0.5, float dy = 0.5);
im_lower_color: BM implicit_api::render_lower_color(IM obj = , float size_x = 300.0, float size_y = 300.0, int sx = 255, int sy = 255, float dx = 0.5, float dy = 0.5);
fo_from_volume: FO float_volume_api::from_volume(O o = , float false_val = 0.0, float true_val = 1.0);
wv_sphere: FO float_volume_api::waveform_sphere(WV wave = , float r = 200.0);
fo_from_fbm: FO float_volume_api::from_float_bitmap(FB bm = , float start_x = 0.0, float end_x = 100.0, float start_y = 0.0, float end_y = 100.0, float start_z = 0.0, float end_z = 100.0);
fo_move: FO float_volume_api::move(FO f1 = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
fo_min: FO float_volume_api::minimum(FO f1 = , FO f2 = );
fo_max: FO float_volume_api::maximum(FO f1 = , FO f2 = );
fo_min_distance: FO float_volume_api::min_distance(C curve = );
fo_subvolume: O float_volume_api::subvolume(FO f = , float start_range = 0.5, float end_range = 1.0);
fo_interpolate: FO float_volume_api::interpolate(FO f1 = , FO f2 = , float val = 0.5);
fo_smooth: FO float_volume_api::smooth([FO] vec = , float val = 0.01);
fo_normal: VO vector_volume_api::normal2(FO fo = , float stepsize = 0.1);
setup_normal: P vector_volume_api::setup_normal(P orig = , VO v = );
fd_sphere: FD dist_api::fd_sphere(PT center = , float radius = 100.0);
fd_cube: FD dist_api::fd_cube(float start_x = -100.0, float end_x = 100.0, float start_y = -100.0, float end_y = 100.0, float start_z = -100.0, float end_z = 100.0);
fd_round_cube: FD dist_api::fd_round_cube(float start_x = -100.0, float end_x = 100.0, float start_y = -100.0, float end_y = 100.0, float start_z = -100.0, float end_z = 100.0, float r = 10.0);
fd_torus: FD dist_api::fd_torus(float r_1 = 100.0, float r_2 = 30.0);
fd_line: FD dist_api::fd_line(PT start = , PT end = , float dist = 10.0);
fd_min: FD dist_api::fd_min(FD a1 = , FD a2 = );
fd_max: FD dist_api::fd_max(FD a1 = , FD a2 = );
fd_and_not: FD dist_api::fd_and_not(FD a1 = , FD a2 = );
fd_blend: FD dist_api::fd_blend(FD a1 = , FD a2 = , float k = 15.0);
fd_color: FD dist_api::fd_color(FD fd = , float r = 1.0, float g = 1.0, float b = 1.0, float a = 1.0);
fd_trans: FD dist_api::fd_trans(FD fd = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
fd_rot_x: FD dist_api::fd_rot_x(FD fd = , float angle = 0.0);
fd_rot_y: FD dist_api::fd_rot_y(FD fd = , float angle = 0.0);
fd_rot_z: FD dist_api::fd_rot_z(FD fd = , float angle = 0.0);
fd_normal: VO vector_volume_api::normal(FD fd = );
fd_recalc_normals: FD dist_api::recalculate_normals(FD fd = );
fd_amb_occul: FD dist_api::ambient_occulsion(FD fd = , float d = 10.2, float i = 30.0);
fd_render2: BM dist_api::render2(EveryApi& ev = ev, FD obj = , int sx = 300, int sy = 300);
fd_render_bm: BM dist_api::render(FD obj = , PT pos = , V u_x = , V u_y = , V u_z = , int sx = 100, int sy = 100);
fd_render_p: P dist_api::distance_poly(EveryApi& ev = ev, FD fd = , float dx = 400.0, float dy = 400.0, float dz = 400.0, int sx = 256, int sy = 256, float ssx = 400.0, float ssy = 400.0, int ssxi = 50, int ssyi = 50, float ssx2 = 100.0, float ssy2 = 100.0);
fd_render_cyl_p: P dist_api::distance_poly_cyl(EveryApi& ev = ev, FD fd = , float pos_x = 0.0, float pos_y = -600.0, float pos_z = 0.0, float dx = 300.0, float dy = 1200.0, float dz = 300.0, int sx = 50, int sy = 50, float ssx = 40.0, float ssy = 40.0, int ssxi = 50, int ssyi = 50, float ssx2 = 50.0, float ssy2 = 50.0);
fd_render_sph_p: P dist_api::distance_poly_sph(EveryApi& ev = ev, FD fd = , float dx = 400.0, float dy = 400.0, float dz = 400.0, int sx = 256, int sy = 256, float ssx = 40.0, float ssy = 40.0, int ssxi = 50, int ssyi = 50, float ssx2 = 50.0, float ssy2 = 50.0);
cov_from_fo: COV color_volume_api::from_float_volume(FO fo = , unsigned int color0 = ff888888, unsigned int color1 = ffffffff);
cov_from_o: COV color_volume_api::from_volume(O obj = , unsigned int col_true = ffffffff, unsigned int col_false = ff888888);
cov_from_cbm: COV color_volume_api::from_continuous_bitmap(CBM bm = );
cov_mix: COV color_volume_api::mix(COV p1 = , COV p2 = , float value = 0.5);
cov_color_from_normal: COV color_volume_api::directcolor(VO normal = );
score_adder: ML mainloop_api::score_adder(EveryApi& ev = ev, ML ml = , O o = , MN mn = , int enter_score = 1, int leave_score = 0, int dyn_point = -1, float timeout = 5.0);
score_adder2: ML mainloop_api::score_adder2(EveryApi& ev = ev, ML ml = , O o = , PTS points = , MN mn = , int enter_score = 1, int leave_score = 0, int dyn_point = -1, float timeout = 5.0, IF fetcher = );
score_hidder: ML mainloop_api::score_hidder(EveryApi& ev = ev, ML ml = , O o = , int max_count = 50);
FI_load: FI font_api::load_font(std::string url = http://tpgames.org/Chunkfive.otf, int sx = 200, int sy = 200);
FI_drawtext: BM font_api::draw_text_string(FI font = , std::string str = Hello, int x_gap = 5, int line_height = 30);
FI_largetext: BM font_api::draw_text_large(EveryApi& ev = ev, FI font = , std::string texturl = http://tpgames.org/text_test.txt, int x_gap = 5, int line_height = 30, int baseline_separation = -1);
FI_save_dump: ML font_api::save_font_dump(FI font = , std::string chars = 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!"#%&/()=?+\*^.,-<>|;:[]_ , std::string filename = font.txt);
FI_load_dump: FI font_api::load_font_dump(std::string url = http://tpgames.org/font.txt);
bm_array_id: [BM] font_api::bm_array_id([BM] vec = );
bm_chooser: ML font_api::dynamic_character(EveryApi& ev = ev, [BM] vec = , IF fetcher = , int x = 0, int y = 0);
p_chooser: ML font_api::dynamic_polygon(EveryApi& ev = ev, [P] vec = , MT mat = , IF fetcher = );
ml_chooser: ML font_api::ml_chooser([ML] vec = , IF fetcher = );
if_toggle: IF font_api::toggle_button_fetcher(float start_x = 0.0, float end_x = 800.0, float start_y = 0.0, float end_y = 600.0);
if_timed: IF font_api::timed_int_fetcher(EveryApi& ev = ev, int start = 0, int end = 10, float start_time = 0.0, float end_time = 30.0);
if_move: IF font_api::movement_int_fetcher(int count = 10, float x_mult = 0.1, float y_mult = 0.1, float z_mult = 0.1);
if_repeat: IF font_api::repeat_int_fetcher(IF fetcher = , float duration = 30.0);
if_keypress: IF font_api::keypress_int_fetcher(int key = 32, int key_down_value = 1, int key_up_value = 0);
if_statemachine: IF mainloop_api::state_int_fetcher(std::string url = http://tpgames.org/move.sm, std::string states = s0&s1&s2&s3&s4);
if_hmd: IF font_api::hmd_state_fetcher();
uv_face: UV mainloop_api::face_fetcher(P p = , int facenum = 0);
ff_choose: FF font_api::choose_float_fetcher(IF int_fetcher = , float a_0 = 0.0, float a_1 = 0.0, float a_2 = 0.0, float a_3 = 0.0, float a_4 = 0.0, float a_5 = 0.0, float a_6 = 0.0);
ff_time: FF font_api::time_fetcher2(EveryApi& ev = ev);
pf_constant: PF font_api::point_fetcher_constant(float x = 0.0, float y = 0.0, float z = 0.0);
pf_mouse: PF font_api::mouse_fetcher();
pf_component: PF font_api::point_fetcher_part(PF point_fetcher = , int component = 0, FF float_fetcher = );
fnt_fps: FF font_api::fps_fetcher(EveryApi& ev = ev);
fnt_float_to_string: SF font_api::float_to_string_fetcher(FF fetcher = );
fnt_char_idx: IF font_api::char_fetcher_from_string(SF string_fetcher = , std::string alternatives = 0123456789, int idx = 0);
pf_x: IF font_api::x_comp(PF point_fetcher = , float start_x = 0.0, float end_x = 300.0, int numsteps = 8);
pf_y: IF font_api::y_comp(PF point_fetcher = , float start_y = 0.0, float end_y = 300.0, int numsteps = 8);
pf_z: IF font_api::z_comp(PF point_fetcher = , float start_z = 0.0, float end_z = 300.0, int numsteps = 8);
tree_level: TL tree_api::level([MN] vec = );
tree: T tree_api::tree([TL] vec = );
tree_p: P tree_api::tree_p(EveryApi& ev = ev, T tree = , [P] vec = , float time = 0.0);
tex_plane: TX texture_api::tex_plane(float sx = 256, float sy = 256);
tex_bitmap: TX texture_api::tex_bitmap(BM bm = );
tex_assign: TX texture_api::tex_assign(TX tx = , int id = 0, int x = 0, int y = 0, BM bm = );
tex_coord: TX texture_api::tex_coord(TX tx = , int id = 0, int x = 0, int y = 0, int width = 100, int height = 100);
get_tex_coord: Q texture_api::get_tex_coord(TX tx = , int id = 0);
tx_prepare: TXID texture_api::prepare(TX tx = );
tx_bind: VA texture_api::bind(VA va = , TXID txid = );
tx_prepare_arr: TXA texture_api::prepare_arr(EveryApi& ev = ev, [BM] vec = , int sx = 255, int sy = 255);
tx_bind_arr: VA texture_api::bind_arr(VA va = , TXA txa = );
tx_to_bitmap: BM texture_api::to_bitmap(TXID txid = );
fbo_id: TXID fbo_api::fbo_ml(EveryApi& ev = ev, ML mainloop = , int sx = -1, int sy = -1, bool translate = false);
depth_id: TXID fbo_api::depth_ml(EveryApi& ev = ev, ML mainloop = , int sx = -1, int sy = -1, bool translate = false);
fbo_pos: ML polygon_api::position_based_on_screen(ML obj = );
fbo_ml: ML fbo_api::fbo_ml_blit(EveryApi& ev = ev, TXID txid = , float start_x = 0.0, float end_x = 800, float start_y = 0.0, float end_y = 600, float z = 0.0);
create_bo: BO bool_api::create_bo(P mesh = , O bools = , FD fd = );
cube_bo: BO bool_api::cube_bo(EveryApi& ev = ev, float start_x = 0.0, float end_x = 100.0, float start_y = 0.0, float end_y = 100.0, float start_z = 0.0, float end_z = 100.0, int split_x = 18, int split_y = 18);
sphere_bo: BO bool_api::sphere_bo(EveryApi& ev = ev, PT center = , float radius = 100.0, int numfaces1 = 30, int numfaces2 = 30);
or_elem_bo: BO bool_api::or_elem_bo(EveryApi& ev = ev, BO obj = , BO obj2 = );
and_not_bo: BO bool_api::and_not_bo(EveryApi& ev = ev, BO obj = , BO not_obj = );
intersect_bo: BO bool_api::intersect_bo(EveryApi& ev = ev, BO obj = , BO obj2 = );
to_poly: P bool_api::to_polygon(BO obj = );
to_volume: O bool_api::to_volume(BO obj = );
to_dist: FD bool_api::to_dist(BO obj = );
mn_empty: MN move_api::mn_empty();
mn_custom: MN move_api::level(MN mn = );
mn_translate: MN move_api::trans2(MN next = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
mn_scale: MN move_api::scale2(MN next = , float sx = 1.0, float sy = 1.0, float sz = 1.0);
mn_rotatex: MN move_api::rotatex(MN next = , float angle = 0.0);
mn_rotatey: MN move_api::rotatey(MN next = , float angle = 0.0);
mn_rotatez: MN move_api::rotatez(MN next = , float angle = 0.0);
mn_hmd_pose: MN move_api::pose(MN next = , bool pose_in_screen = false);
mn_statemachine: MN mainloop_api::state_speed_movement(MN mn = , std::string url = http://tpgames.org/move.sm, std::string states = s0&s1&s2&s3&s4, std::string x_speeds = 0.0&-1.0&0.0&0.0&1.0, std::string y_speeds = 0.0&0.0&-1.0&1.0&0.0, std::string z_speeds = 0.0&0.0&0.0&0.0&0.0);
mn_scale_progress: MN move_api::scale_progress(MN next = , bool is_x = true, bool is_y = false, bool is_z = false);
mn_pos_fetcher: MN move_api::mn_fetcher(PF point_fetcher = );
mn_interpolate: MN move_api::interpolate(MN n1 = , MN n2 = , float start_time = 0.0, float end_time = 30.0, float start_value = 0.0, float end_value = 1.0);
local_move: ML move_api::local_move(EveryApi& ev = ev, ML inner_ml = , PTS center_points = );
local_move_mat: ML move_api::local_move_matrix(EveryApi& ev = ev, ML inner_ml = , MS matrices = );
anim_translate: MN move_api::translate(MN next = , float start_time = 0.0, float end_time = 100.0, float dx = 0.0, float dy = 0.0, float dz = 0.0);
anim_scale: MN move_api::scale(MN next = , float start_time = 0.0, float end_time = 100.0, float sx = 1.0, float sy = 1.0, float sz = 1.0);
anim_rotate: MN move_api::rotate(MN next = , float start_time = 0.0, float end_time = 100.0, float p_x = 0.0, float p_y = 0.0, float p_z = 0.0, float v_x = 0.0, float v_y = 1.0, float v_z = 0.0, float angle = 6.28318);
wave_translate: MN move_api::translate_wave(MN next = , float start_time = 0.0, float end_time = 100.0, WV wave = , float dx = 0.0, float dy = 0.0, float dz = 0.0);
wave_scale: MN move_api::scale_wave(MN next = , float start_time = 0.0, float end_time = 100.0, WV wave = , float sx = 1.0, float sy = 1.0, float sz = 1.0);
wave_rotate: MN move_api::rotate_wave(MN next = , float start_time = 0.0, float end_time = 100.0, WV wave = , float p_x = 0.0, float p_y = 0.0, float p_z = 0.0, float v_x = 0.0, float v_y = 1.0, float v_z = 0.0, float angle = 6.28318);
anim_compress: MN move_api::compress(MN next = , float start_time = 0.0, float end_time = 100.0);
anim_time: MN move_api::change_time(MN next = , float delta_time = 0.0);
anim_repeat: MN move_api::time_repeat(MN next = , float start_time = 0.0, float repeat_duration = 100.0);
anim_enable: MN move_api::anim_enable(MN next = , float start_time = 0.0, float end_time = 100.0);
anim_disable: MN move_api::anim_disable(MN next = , float start_time = 0.0, float end_time = 100.0);
anim_choose: MN move_api::anim_choose([MN] vec = , float start_time = 0.0, float duration = 100.0);
anim_event: MN move_api::event_activate(MN next = , MN event = , float event_time = 10.0, float event_duration = 100.0);
color_start: CC move_api::color_start(unsigned int color = ffffffff);
color_interpolate: CC move_api::color_interpolate(CC next = , unsigned int start_color = ffffffff, unsigned int end_color = ff888888, float start_time = 0.0, float end_time = 100.0);
move_normal: INP mainloop_api::cursor_keys_normal_move();
move_rotate: INP mainloop_api::cursor_keys_rotate_move(float speed_rot = 0.3141, float r_forward = 1.0, float r_normal = 0.0, float r_backward = -1.0);
move_speed: INP mainloop_api::move_speed(INP orig = , float speed = 1.0);
move_coll: INP mainloop_api::move_collision(IBM scene = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float s_x = -5.0, float m_x = 0.0, float e_x = 5.0, float s_y = 5.0, float m_y = 0.0, float e_y = -5.0, float speed_up = 20.0, float speed_down = -10.0, float speed_left = -10.0, float speed_right = 10.0, float speed_gravity = -10.0);
move_sequence: INP mainloop_api::move_sequence(float start_time = 0.0, float time_per_char = 3.0, std::string string = wwddssaa);
move_gravity: INP mainloop_api::gravity(INP inp = , IBM scene = , float start_x = 0.0, float end_x = 800.0, float start_y = 0.0, float end_y = 600.0, float speed = 10.0);
sa_root: SA skeletal_api::root(PT points = );
sa_node: SA skeletal_api::node(SA parent = , MN matrix = , PT point_offset = );
move_x_ml: ML move_api::move_x_ml(EveryApi& ev = ev, ML ml = , int key_forward = 100, int key_backward = 97, float speed = 5.0, float start_x = -100.0, float end_x = 100.0);
move_y_ml: ML move_api::move_y_ml(EveryApi& ev = ev, ML ml = , int key_forward = 119, int key_backward = 115, float speed = 5.0, float start_y = -100.0, float end_y = 100.0);
move_z_ml: ML move_api::move_z_ml(EveryApi& ev = ev, ML ml = , int key_forward = 107, int key_backward = 109, float speed = 5.0, float start_z = -100.0, float end_z = 100.0);
jump_ml: ML move_api::jump_ml(EveryApi& ev = ev, ML ml = , int key_jump = 32, float height = 300.0, float jump_duration = 10.0);
kf_mesh: KF vertex_anim_api::keyframe_mesh(P part = );
kf_lines: KF vertex_anim_api::keyframe_lines(LI part = );
kf_bind: KF vertex_anim_api::keyframe_bind(EveryApi& ev = ev, KF keyframe = , PTT transform = , float delta_time = 10.0);
kf_repeat: KF vertex_anim_api::repeat_keyframes(KF keyframe = , int count = 100);
kf_curve: KF vertex_anim_api::curve_trans(EveryApi& ev = ev, KF keyframe = , C curve = , CPP pos = , int numsamples = 10, float duration = 30.0);
kf_rot: KF vertex_anim_api::sample_rot(EveryApi& ev = ev, KF kf = , float nx = 0.0, float ny = 1.0, float nz = 0.0, float angle = 6.282, int numsamples = 15, float duration = 30.0);
ptt_empty: PTT vertex_anim_api::empty_trans();
ptt_trans_s: PTT vertex_anim_api::translate_trans(PTT prev = , float speed_x = 0.0, float speed_y = 0.0, float speed_z = 0.0);
ptt_trans_d: PTT vertex_anim_api::translate_trans2(PTT prev = , float duration = 10.0, float dist_x = 0.0, float dist_y = 0.0, float dist_z = 0.0);
ptt_scale_s: PTT vertex_anim_api::scale_trans(PTT prev = , float speed_x = 1.0, float speed_y = 1.0, float speed_z = 1.0);
ptt_scale_d: PTT vertex_anim_api::scale_trans2(PTT prev = , float duration = 10.0, float dist_x = 1.0, float dist_y = 1.0, float dist_z = 1.0);
create_pd: PD polygon_dist_api::create_pd(P mesh = , SFO dist_field = );
cube_pd: PD polygon_dist_api::cube_pd(EveryApi& ev = ev, float start_x = 0.0, float end_x = 100.0, float start_y = 0.0, float end_y = 100.0, float start_z = 0.0, float end_z = 100.0);
rounded_cube_pd: PD polygon_dist_api::rounded_cube(EveryApi& ev = ev, float start_x = -100.0, float end_x = 100.0, float start_y = -100.0, float end_y = 100.0, float start_z = -100.0, float end_z = 100.0, float radius = 20.0);
sphere_pd: PD polygon_dist_api::sphere_pd(EveryApi& ev = ev, PT center = , float radius = 100.0, int numfaces1 = 30, int numfaces2 = 30);
or_array_pd: PD polygon_dist_api::or_array(EveryApi& ev = ev, [PD] vec = );
pd_color_from_normal: PD polygon_dist_api::color_from_normal_pd(EveryApi& ev = ev, PD obj = );
pd_colormod: PD polygon_dist_api::colormod_from_position(EveryApi& ev = ev, PD obj = , float px = 0.0, float py = 0.0, float pz = 0.0, float sx = 100.0, float sy = 100.0, float sz = 100.0);
ambient_occulsion_sfo: PD polygon_dist_api::ambient_occulsion_sfo(EveryApi& ev = ev, PD obj = , float d = 10.2, float i = 30.0);
to_sfo: SFO poly_dist_api::get_distance_field(PD pd = );
to_p: P poly_dist_api::get_polygon(PD pd = );
mesh_color_from_sfo: MT poly_dist_api::mesh_color_from_sfo(EveryApi& ev = ev, PD pd = , MT mat = );
wv_empty: WV waveform_api::wv_empty(float length = 1.0);
wv_step: WV waveform_api::step(bool flip = false);
wv_sin: WV waveform_api::sinwave(float length = 6.28318, float freq = 1.0);
wv_gaussian: WV waveform_api::gaussian(float start_x = -100.0, float end_x = 100.0, float start_y = -1.0, float end_y = 1.0);
wv_sum: WV waveform_api::sum(WV w1 = , WV w2 = );
wv_move: WV waveform_api::move(WV w1 = , float delta = 0.0);
wv_move_y: WV float_volume_api::wave_move_y(WV wave = , float delta = 0.0);
wv_scale: WV waveform_api::scale(WV w1 = , float scale = 1.0);
wv_rot_poly: P waveform_api::waveform_rotated_polygon(WV wave = , float start_angle = 0.0, float end_angle = 6.28318, float radius = 300.0, int num_samples = 40, int num_waves = 40);
wv_cubic: WV waveform_api::cubic(float f_0 = 0.0, float f_1 = 0.0, float df_0 = 0.5, float df_1 = -0.5, float min_y = -5.0, float max_y = 5.0);
wv_repeat: WV waveform_api::repeat(WV wave = , int num = 2);
wv_set_length: WV waveform_api::length_change(WV wave = , float new_length = 1.0);
wv_bitmap: BM waveform_api::waveform_bitmap(WV wave = , int sx = 100, int sy = 100, unsigned int true_color = ffffffff, unsigned int false_color = 00000000);
pn_std: PN waveform_api::std_polynomial(float x_5 = 0.0, float x_4 = 0.0, float x_3 = 0.0, float x_2 = 0.0, float x_1 = 0.0, float c = 0.0);
pn_df_dx: PN waveform_api::df_dx(PN poly = );
wv_polynomial: WV waveform_api::polynomial_wave(PN pn = , float start_x = -5.0, float end_x = 5.0, float start_y = 5.0, float end_y = -5.0);
bm_script: BM mainloop_api::load_BM_script(EveryApi& ev = ev, std::string url = http://tpgames.org/tiiliseina_bm.mp, std::string %1 = a, std::string %2 = b, std::string %3 = c, std::string %4 = d, std::string %5 = e);
p_script: P mainloop_api::load_P_script(EveryApi& ev = ev, std::string url = http://tpgames.org/blob_p.mp, std::string %1 = a, std::string %2 = b, std::string %3 = c, std::string %4 = d, std::string %5 = e);
ml_script: ML mainloop_api::load_ML_script(EveryApi& ev = ev, std::string url = http://tpgames.org/marble_cube_ml.mp, std::string %1 = a, std::string %2 = b, std::string %3 = c, std::string %4 = d, std::string %5 = e);
mn_script: MN mainloop_api::load_MN_script(EveryApi& ev = ev, std::string url = http://tpgames.org/test_mn.mp, std::string %1 = a, std::string %2 = b, std::string %3 = c, std::string %4 = d, std::string %5 = e);
mt_script: MT mainloop_api::load_MT_script(EveryApi& ev = ev, std::string url = http://tpgames.org/test_mt.mp, std::string %1 = a, std::string %2 = b, std::string %3 = c, std::string %4 = d, std::string %5 = e);
bm_script_arr: [BM] mainloop_api::load_BM_script_array(EveryApi& ev = ev, std::string url = http://tpgames.org/tiiliseina_bm.mp, std::string %1 = a&a, std::string %2 = b&b, std::string %3 = c&c, std::string %4 = d&d, std::string %5 = e&e);
p_script_arr: [P] mainloop_api::load_P_script_array(EveryApi& ev = ev, std::string url = http://tpgames.org/blob_p.mp, std::string %1 = a&a, std::string %2 = b&b, std::string %3 = c&c, std::string %4 = d&d, std::string %5 = e&e);
ml_script_arr: [ML] mainloop_api::load_ML_script_array(EveryApi& ev = ev, std::string url = http://tpgames.org/marble_cube_ml.mp, std::string %1 = a&a, std::string %2 = b&b, std::string %3 = c&c, std::string %4 = d&d, std::string %5 = e&e);
ml_chai: ML mainloop_api::chai_mainloop(EveryApi& ev = ev, std::string url = http://tpgames.org/chai_example.txt);
ml_gltf: ML mainloop_api::gltf_mesh(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb, int mesh_id = 0);
ml_gltf_node: ML mainloop_api::gltf_node(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb, int node_id = 0);
ml_gltf_scene: ML mainloop_api::gltf_scene(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb, int scene_id = 0);
ml_gltf_all: ML mainloop_api::gltf_mesh_all(EveryApi& ev = ev, std::string base_url = http://tpgames.org/, std::string url = http://tpgames.org/test.glb);
scene_ml: ML polygon_api::load_scene(EveryApi& ev = ev, std::string url = http://tpgames.org/landscape.scn, int sx = 600, int sy = 600);
piechart_ml: ML polygon_api::piechart_full(EveryApi& ev = ev, float c_x = 0.0, float c_y = 0.0, std::string url = http://tpgames.org/piechart_full.txt, float radius = 350.0, int numsteps = 30, float start_z = 0.0, float end_z = 40.0);
skybox_ml: ML mainloop_api::skybox(EveryApi& ev = ev, BM land = , BM sky = );
alt_ml: ML sprite_api::alt_ml_array(EveryApi& ev = ev, [ML] vec = , float start_time = 0.0, float time_delta = 10.0, bool repeat = true);
array_ml: ML mainloop_api::array_ml(EveryApi& ev = ev, [ML] arr = );
activate_array_ml: ML mainloop_api::activate_array([ML] arr = );
ac_arr_ml: [ML] mainloop_api::activate_arr_arr([ML] arr = );
seq_ml: ML mainloop_api::seq_ml([ML] vec = , float time = 30.0);
seq_ml_score: ML mainloop_api::seq_ml_score(ML ml1 = , ML ml2 = , int target_score = 100);
timed_tmp_seq_ml: ML mainloop_api::timed_tmp_seq_ml(ML curr = , ML end = , float start_time = 0.0, float end_time = 100.0, float show_duration = 30.0, int key = 32);
move_ml: ML move_api::move_ml(EveryApi& ev = ev, ML ml = , MN mn = , int clone_count = 1, float time_delta = 10.0);
move_in: ML mainloop_api::move_in(EveryApi& ev = ev, ML ml = , INP in = );
dyn_points_ml: ML mainloop_api::dyn_points(EveryApi& ev = ev, ML ml = , MN move = , int pointnum = 0, float pos_x = 0.0, float pos_y = 0.0, float pos_z = 0.0);
repeat_ml: ML move_api::repeat_ml(EveryApi& ev = ev, ML ml = , float duration = 100.0);
bm_render: ML sprite_api::vertex_array_render(EveryApi& ev = ev, BM bm = );
bm_2d: ML sprite_api::turn_to_2d(EveryApi& ev = ev, ML ml = , float tl_x = 0.0, float tl_y = 0.0, float br_x = 800.0, float br_y = 600.0);
bm_2d_screen_scale: ML mainloop_api::scale_2d_screen(EveryApi& ev = ev, ML orig = , float sx = 1024, float sy = 768);
sp_render: ML polygon_api::sprite_render(EveryApi& ev = ev, BM bm = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float z = 0.0);
sp_render_inst: ML polygon_api::sprite_render_inst(EveryApi& ev = ev, BM bm = , PTS pts = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float z = 0.0);
sp_render_fade: ML polygon_api::sprite_render_fade(EveryApi& ev = ev, BM bm = , PTS pts = , float start_x = -200.0, float end_x = 200.0, float start_y = -200.0, float end_y = 200.0, float z = 0.0, bool flip = false, float start_time = 10.0, float end_time = 40.0);
p_render: ML polygon_api::render_vertex_array_ml2(EveryApi& ev = ev, P p = );
p_render_inst: ML materials_api::render_instanced_ml(EveryApi& ev = ev, P p = , PTS pts = );
p_render_dyn: ML polygon_api::render_dynamic_ml(EveryApi& ev = ev, P p = , DC dyn = );
p_render_inst_fade: ML materials_api::render_instanced_ml_fade(EveryApi& ev = ev, P p = , PTS pts = , bool flip = false, float start_time = 10.0, float end_time = 40.0);
p_render_inst2: ML materials_api::render_instanced2_ml(EveryApi& ev = ev, VA va = , PTA pta = );
pts_render: ML points_api::pts_render(EveryApi& ev = ev, PTS pts = );
li_prepare: LLA lines_api::prepare(LI li = );
li_render: ML lines_api::render_ml(EveryApi& ev = ev, LLA lla = , float linewidth = 1.0);
sfo_render: ML sh_api::sfo_to_ml(EveryApi& ev = ev, SFO sfo = , float sx = -1.0, float sy = -1.0);
o_to_pts: PTS volume_api::instanced_positions(O object = , int sx = 30, int sy = 30, int sz = 30, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0);
o_render: P volume_api::rendercubes3(O object = , int sx = 100, int sy = 100, int sz = 100, float start_x = -300.0, float end_x = 300.0, float start_y = -300.0, float end_y = 300.0, float start_z = -300.0, float end_z = 300.0);
m_bind: ML materials_api::bind(P p = , MT mat = );
m_bind_inst: ML materials_api::bind_inst(P p = , PTS pts = , MT mat = );
m_bind_inst_mat: ML materials_api::bind_inst_matrix(P p = , MS ms = , MT mat = );
m_bind_inst_many: ML polygon_api::m_bind_inst_many(EveryApi& ev = ev, [P] vec = , [MT] mat = , PTS pts = );
m_fade_inst: ML materials_api::bind_inst_fade(P p = , PTS pts = , MT mat = , bool flip = false, float start_time = 10.0, float end_time = 40.0);
rot_x_ml: ML move_api::rot_x_ml(EveryApi& ev = ev, ML ml = , int key_forward = 100, int key_backward = 97, float speed = 0.01, float start_angle = -100000.0, float end_angle = 100000.0);
rot_y_ml: ML move_api::rot_y_ml(EveryApi& ev = ev, ML ml = , int key_forward = 100, int key_backward = 97, float speed = 0.01, float start_y = -100.0, float end_y = 100.0);
rot_z_ml: ML move_api::rot_z_ml(EveryApi& ev = ev, ML ml = , int key_forward = 100, int key_backward = 97, float speed = 0.01, float start_z = -100000.0, float end_z = 100000.0);
enable_ml: ML move_api::enable_ml(EveryApi& ev = ev, ML ml = , float start_time = 0.0, float end_time = 100.0);
color_ml: ML move_api::color_ml(EveryApi& ev = ev, int color_num = 0, ML ml = , CC cc = );
wasd_ml: ML move_api::all_cursor_keys(EveryApi& ev = ev, ML ml = , float speed = 8.0, float duration = 1.0);
quake_ml: ML move_api::quake_ml(EveryApi& ev = ev, ML ml = , float speed = 20.0, float rot_speed = 0.03);
quake_ml2: ML move_api::quake_ml2(EveryApi& ev = ev, ML ml = , float speed = 20.0, float rot_speed = 0.03);
fly_ml: ML move_api::quake_ml3(EveryApi& ev = ev, ML ship = , ML world = , float speed = 20.0, float rot_speed = 0.03, float p_x = 0.0, float p_y = 0.0, float p_z = 0.0);
debug_obj: ML mainloop_api::debug_obj(EveryApi& ev = ev);
key_activate_ml: ML move_api::key_activate_ml(EveryApi& ev = ev, ML ml = , MN mn = , int key = 32, float duration = 10.0);
tmp_key_activate_ml: ML move_api::temp_key_activate_ml(EveryApi& ev = ev, ML ml = , MN mn = , int key = 32, float duration = 10.0);
comb_key_activate_ml: ML move_api::comb_key_activate_ml(EveryApi& ev = ev, ML ml = , MN mn = , int key = 32, int key_2 = 32, float duration = 10.0);
key_toggle: ML mainloop_api::keyboard_toggle(ML ml1 = , ML ml2 = , int key = 32);
touch_rotate: ML mainloop_api::touch_rotate(EveryApi& ev = ev, ML ml = , bool leftright = true, bool topdown = true, float x_speed = 0.01, float y_speed = 0);
key_record_ml: ML mainloop_api::record_keypresses(ML ml = , std::string output_filename = key_record.txt);
key_playback_ml: ML mainloop_api::playback_keypresses(ML ml = , std::string input_url = http://tpgames.org/key_record.txt);
key_printer_ml: ML move_api::key_printer_ml(ML ml = );
fps_display: ML mainloop_api::fps_display(EveryApi& ev = ev, ML ml = , std::string font = http://tpgames.org/Chunkfive.otf);
w_areatype: ML mainloop_api::parse_areatype(EveryApi& ev = ev, std::string url = https://tpgames.org/areatype.txt, FB heightmap = , BM top_texture = , BM side_texture = );
w_landscape: ML mainloop_api::create_landscape(EveryApi& ev = ev, std::string url = https://tpgames.org/landscape.txt);
w_objtype: ML mainloop_api::bind_obj_type(EveryApi& ev = ev, std::string url = https://tpgames.org/objtype.txt);
w_objpos: ML mainloop_api::read_obj_pos(std::string url = https://tpgames.org/objpos.txt);
w_objs: ML mainloop_api::create_objs(EveryApi& ev = ev, int area_id = 0);
globe_shader: ML polygon_api::globe_shader(EveryApi& ev = ev, ML mainloop = , float globe_r = 1.0);
score_display: ML mainloop_api::score_display(EveryApi& ev = ev, ML ml = , std::string font = http://tpgames.org/Chunkfive.otf);
time_display: ML mainloop_api::time_display(EveryApi& ev = ev, ML ml = , std::string font = http://tpgames.org/Chunkfive.otf, float time = 1000.0);
matrix_range_check: ML mainloop_api::matrix_range_check(EveryApi& ev = ev, ML ml = , ML ml2 = , std::string url = http://tpgames.org/test_data.txt);
restart_key: ML mainloop_api::restart_game(EveryApi& ev = ev, ML ml = , int key = 114);
restart_screen: ML mainloop_api::restart_screen(EveryApi& ev = ev, ML ml = , std::string fontname = http://tpgames.org/Chunkfive.otf);
skeletal_bind: ML skeletal_api::skeletal_bind(EveryApi& ev = ev, [P] model = , [PT] points = , [SA] movement = );
skeletal_material: ML skeletal_api::skeletal_bind_material(EveryApi& ev = ev, [P] model = , [PT] points = , [SA] movement = , MT material = );
tree_ml: ML tree_api::tree_ml(EveryApi& ev = ev, T tree = , [ML] vec = );
kf_render: ML vertex_anim_api::vertex_anim_render(EveryApi& ev = ev, KF keyframe = );
ogl_depthfunc: ML mainloop_api::depthfunc(ML ml = , int val = 1);
ogl_blendfunc: ML mainloop_api::blendfunc(ML ml = , int val = 2, int val2 = 3);
song_ml: ML mainloop_api::load_song(EveryApi& ev = ev, ML next = , std::string url = http://tpgames.org/piano_variations.ogg);
sound_ml: ML tracker_api::play_wave_via_keypress(EveryApi& ev = ev, ML ml = , std::string url = http://tpgames.org/Clap.wav, int key = 32);
blk_window: BLK blocker_api::game_window(EveryApi& ev = ev, ML ml = , bool logo = false, bool fpscounter = false, float start_time = 0.0, float duration = 100000.0);
run_window: RUN blocker_api::game_window2(EveryApi& ev = ev, ML ml = , bool logo = false, bool fpscounter = false, float start_time = 0.0, float duration = 100000.0);
html_window: HML mainloop_api::emscripten_frame(EveryApi& ev = ev, RUN r = , std::string homepage = http://tpgames.org/);
sml_window: ML mainloop_api::small_window(EveryApi& ev = ev, ML ml = , int x = 100, int y = 100, int sx = 320, int sy = 200);
looking_glass_window: RUN blocker_api::game_window_2nd_display(EveryApi& ev = ev, ML ml = , bool logo = false, bool fpscounter = false, float start_time = 0.0, float duration = 1000000.0);
looking_glass_full: ML mainloop_api::looking_glass_full(EveryApi& ev = ev, ML ml = , float amount = 150.0, int mode = 0, int start = 0, int end = 45);
vr_window: RUN blocker_api::vr_window(EveryApi& ev = ev, ML ml = , bool logo = false, bool fpscounter = false, float start_time = 0.0, float duration = 100000.0, bool invert = true, bool translate = true);
fr_sprite_draw: FML low_frame_api::low_sprite_draw(std::string name = s_tmp1, BM bm = , MN move = , int x = 0, int y = 0, int fmt = 1, float start_time = 0.0);
fr_sprite_array: FML low_frame_api::low_sprite_array(std::string name = a_tmp1, std::string url = http://tpgames.org/pos_lst.sp, [BM] bms = , MN mn = , int x = 0, int y = 0, int fmt = 1, float start_time = 0.0);
fr_sprite_choose: FML font_api::dynamic_character_frame(EveryApi& ev = ev, [BM] vec = , IF fetcher = , int x = 0, int y = 0, int fmt = 1, MN mn = );
fr_poly_draw: FML low_frame_api::low_poly_draw(std::string name = p_tmp1, P p = , MN mn = );
fr_world_draw: FML low_frame_api::low_render_world([BM] blocks = , int screen_width = 800, int screen_height = 600, int fmt = 1);
fr_scroll_world: FML low_frame_api::low_scroll_world(FML ml = , float speed_x = 1.0, float speed_y = 1.0, float p_x = 400.0, float p_y = 300.0, float left_offset = 10.0, float right_offset = 10.0, float height = 5.0, float height2 = 30.0, int mode = 0, int jump_frames = 15);
fr_build_world: FML low_frame_api::low_build_world(FML ml = , std::string url = http://tpgames.org/map.txt, std::string chars = .#, int x = 0, int y = 0);
fr_enemy_draw: FML low_frame_api::low_enemy_draw(BM bm = , std::string url = http://tpgames.org/enemy0.txt, int fmt = 1, float speed = 0.03);
fr_enemy_draw2: FML low_frame_api::low_enemy_draw2([BM] bm = , std::string url = http://tpgames.org/enemy0.txt, int fmt = 1, float speed = 0.03, int time_delta = 1, int time_duration = 8);
array_fml: FML mainloop_api::array_fml([FML] arr = );
fr_bitmap: BM low_frame_api::low_frame_bitmap(FML ml = , int sx = 800, int sy = 600);
fr_collision: FML low_frame_api::low_collision(FML ml = , float start_x = 100.0, float end_x = 120.0, float start_y = 100.0, float end_y = 120.0, int key = 32);
fr_snapshot: FML low_frame_api::low_activate_snapshot(EveryApi& ev = ev, FML ml = , int key = 32, MN move = , float duration = 30.0, FML next = );
fr_framebuffer: FBU low_frame_api::low_framebuffer(FML mainloop = , int format = 4, int width = 128, int height = 144, int depth = 0);
fr_run: RUN low_frame_api::low_framebuffer_run(EveryApi& ev = ev, FBU buffer = , int mode = 0, int scr_x = 128, int scr_y = 144);
w_root: FML low_frame_api::w_root(EveryApi& ev = ev, W wd = );
w_layout: W low_frame_api::w_layout([W] vec = , std::string url = http://tpgames.org/testlayout.lay);
w_rect: W low_frame_api::w_rect(unsigned int color = ffffffff);
w_bitmap: W low_frame_api::w_bitmap(BM bm = );


